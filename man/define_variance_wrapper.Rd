% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_variance_wrapper.R
\name{define_variance_wrapper}
\alias{define_variance_wrapper}
\title{Define a variance estimation wrapper}
\usage{
define_variance_wrapper(variance_function, reference_id, reference_weight,
  default_id = NULL, technical_data = NULL, technical_param = NULL,
  objects_to_include = NULL)
}
\arguments{
\item{variance_function}{An R function. It is the methodological workhorse of 
the estimation of variance: from a set of arguments including the variables 
of interest (see below), it should return a vector of estimated variances 
(or a list whose first element is a vector of estimated variances). See Details.}

\item{reference_id}{A vector containing the ids of all the responding units
of the survey. It can also be an unevaluated expression (enclosed in 
\code{quote()}) to be evaluated within the execution environment of the wrapper.
It is compared with \code{default$id} (see below) to check whether 
some observations are missing in the survey file. The matrix of variables 
of interest has \code{reference_id} as rownames and is ordered according
to its values before being processed by \code{variance_function}.}

\item{reference_weight}{A vector containing the reference weight of the survey. 
It can also be an unevaluated expression (enclosed in \code{quote()}) to 
be evaluated within the execution environment of the wrapper.}

\item{default_id}{A character vector of length 1, the name of the default 
identifying variable in the survey file. It can also be an unevaluated 
expression (enclosed in \code{quote()}) to be evaluated within the survey file.}

\item{technical_data}{A named list of technical data needed to perform 
the variance estimation (e.g. sampling strata, first- or second-order 
probabilities of inclusion, estimated response probabilities, calibration 
variables). Its names should match the names of the arguments 
of \code{variance_function}.}

\item{technical_param}{A named list of technical parameters used to control 
some aspect of the variance estimation process (e.g. alternative methodology).
Its names should match the names of the arguments  of \code{variance_function}.}

\item{objects_to_include}{(Advanced use) A character vector indicating the name of 
additional R objects to include within the variance wrapper.}
}
\value{
An R function that makes the estimation of variance based on the provided 
variance function easier. Its parameters are:
  \itemize{
   \item \code{data}: the survey data where the interest variables are stored
   \item \code{...}: one or more calls to a statistic wrapper (see examples
   and \code{\link[=standard_statistic_wrapper]{standard statistic wrappers}})
   \item \code{where}: a logical vector indicating a domain on which the variance
   estimation is conducted
   \item \code{by}: a qualitative variable whose levels are used to define domains
   on which the variance estimation is conducted
   \item \code{alpha}: a numeric vector of size 1 indicating the threshold
   for confidence interval derivation. Its default value depends on
   the value of \code{default_alpha} in \code{define_variance_wrapper}
   \item \code{id}: a character vector of size 1 containing the name of
   the identifying variable in the survey file. Its default value depends 
   on the value of \code{default_id} in \code{define_variance_wrapper}
   \item \code{envir}: an environment containing a binding to \code{data}
 }
}
\description{
Given a variance estimation \emph{function} (specific to a 
  survey), \code{define_variance_wrapper} defines a variance estimation 
  \emph{wrapper} easier to use (e.g. automatic domain estimation, 
  linearization).
}
\details{
Defining variance estimation wrappers is the \strong{key feature} of
  the \code{gustave} package. It is the workhorse of the ready-to-use \code{
  \link{qvar}} function and should be used directly to handle more complex
  surveys (e.g. several stages, balanced sampling).
  
  Analytical variance estimation is often difficult to carry out by 
  non-specialists owing to the complexity of the underlying sampling 
  and estimation methodology. This complexity yields complex \emph{variance 
  estimation functions} which are most often only used by the sampling expert 
  who actually wrote them. A \emph{variance estimation wrapper} is an 
  intermediate function that is "wrapped around" the (complex) variance 
  estimation function in order to provide the non-specialist with 
  user-friendly features: \itemize{ \item checks for consistency between the 
  provided dataset and the survey characteristics \item factor discretization
  \item domain estimation \item linearization of complex statistics (see 
  \code{\link[=standard_statistic_wrapper]{standard statistic wrappers}})}
  
  \code{define_variance_wrapper} allows the sampling expert to define a 
  variance estimation wrapper around a given variance estimation function and
  set its default parameters. The produced variance estimation wrapper will 
  be stand-alone in the sense that it can contain all technical data necessary
  to carry out the estimation (see \code{technical_data}).
  
  The arguments of the \code{variance_function} fall into three types: \itemize{
  \item the data argument (mandatory, only one allowed): the numerical matrix of 
  variables of interest to apply the variance estimation formula on
  \item technical data arguments (optional, one or more allowed): technical 
  and methodological information used by the variance estimation function
  (e.g. sampling strata, first- or second-order probabilities of inclusion, 
  estimated response probabilities, calibration variables)
  \item technical parameters (optional, one or more allowed): non-data arguments 
  to be used to control some aspect of the variance estimation (e.g. alternative
  methodology)}
  
  \code{technical_data} and \code{technical_param} are used to determine
  which arguments of \code{variance_function} relate to technical information, 
  the only remaining argument is considered as the data argument.
}
\examples{
### Example from the Labour force survey (LFS)

# The (simulated) Labour force survey (LFS) has the following characteristics:
# - first sampling stage: balanced sampling of 4 areas (each corresponding to 
#   about 120 dwellings) on first-order probability of inclusion (proportional to 
#   the number of dwellings in the area) and total annual income in the area.
# - second sampling stage: in each sampled area, simple random sampling of 20 
#   dwellings
# - neither non-response nor calibration

# As this is a multi-stage sampling design with balanced sampling at the first
# stage, the qvar function does not apply. A variance wrapper can nonetheless
# be defined using the core define_variance_wrapper() function.

# Step 1 : Definition of the variance function and the corresponding technical data

# In this context, the variance estimation function specific to the LFS 
# survey can be defined as follows:

var_lfs <- function(y, ind, dwel, area){
  
  variance <- list()
  
  # Variance associated with the sampling of the dwellings
  y <- sum_by(y, ind$id_dwel)
  variance[["dwel"]] <- var_srs(
    y = y, pik = dwel$pik_dwel, strata = dwel$id_area, 
    w = (1 / dwel$pik_area^2 - dwel$q_area)
  )
  
  # Variance associated with the sampling of the areas
  y <- sum_by(y = y, by = dwel$id_area)
  variance[["area"]] <- varDT(y = y, precalc = area$precalc_area)
  
  colSums(do.call(rbind, variance))
  
}

# where ind, dwel and area are technical data:

technical_data_lfs <- list()

# Technical data at the area level
# The varDT function allows for the pre-calculation of 
# most of the methodological quantities needed (which are
# stored in precalc_area).
precalc_area <- varDT(
  y = NULL, 
  pik = lfs_samp_area$pik_area, 
  x = as.matrix(lfs_samp_area[c("pik_area", "income")]),
  id = lfs_samp_area$id_area
)
technical_data_lfs$area <- list(id_area = lfs_samp_dwel$id_area, precalc_area = precalc_area)

# Technical data at the dwelling level
# In order to implement Rao (1975) formula for two-stage samples,
# we associate each dwelling with the diagonal term corresponding 
# to its area in the first-stage variance estimator: 
lfs_samp_dwel$q_area <- setNames(precalc_area$diago, precalc_area$id)[lfs_samp_dwel$id_area]
technical_data_lfs$dwel <- lfs_samp_dwel[c("id_dwel", "pik_dwel", "id_area", "pik_area", "q_area")]

# Technical data at the individual level
technical_data_lfs$ind <- lfs_samp_ind[c("id_ind", "id_dwel", "sampling_weight")]

# Test of the variance function var_lfs
y <- matrix(as.numeric(lfs_samp_ind$unemp), ncol = 1, dimnames = list(lfs_samp_ind$id_ind))
with(technical_data_lfs, var_lfs(y = y, ind = ind, dwel = dwel, area = area))


# Step 2 : Definition of the variance wrapper

# Call of define_variance_wrapper
precision_lfs <- define_variance_wrapper(
  variance_function = var_lfs,
  technical_data = technical_data_lfs, 
  reference_id = technical_data_lfs$ind$id_ind,
  reference_weight = technical_data_lfs$ind$sampling_weight,
  default_id = "id_ind"
)

# Test
precision_lfs(lfs_samp_ind, unemp)

# The variance wrapper precision_lfs has the same features
# as variance wrappers produced by the qvar function (see
# qvar examples for more details).

}
\seealso{
\code{\link{qvar}} \code{\link[=standard_statistic_wrapper]{standard statistic wrappers}} \code{\link{varDT}}
}
\author{
Martin Chevalier
}
